{"version":3,"sources":["webpack:///./src/ApiClient/TransferClient.ts","webpack:///./src/ApiClient/AdminClient.ts"],"names":["ticket","response","ServerClient","wait4Init","apiClient","TransferController_Download","headers","Accept","stat","InternalStatus","code","StatusCode","ERROR","error","status","OK","payload","data","InternalError","ErrorCode","TRANSFER_NOT_AVAILABLE","errorMessage","UNHANDLED_RESPONSE","axiosResponse","_cachedAdminInfo","loadingAdminInfo","on","undefined","this","Promise","resolve","resolver","user","removeListener","AdministrationController_Read","res","emit","thing","ADMIN_GITHUB_RATE","ADMIN_GITHUB_ERROR","AdministrationController_Delete","ADMIN_WATCHDOG_UNAVAIL","newVersion","AdministrationController_Update","ADMIN_VERSION_NOT_FOUND","AdministrationController_ListLogs","pageSize","page","content","ADMIN_LOGS_IO_ERROR","logName","AdministrationController_GetLog","path","contents","TransferClient","Download","fileTicket","temp","Object","assign","TypedEmitter"],"mappings":"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","file":"2.32d418913d72a864122f.js","sourcesContent":["import { Components } from \"./generatedcode/_generated\";\nimport InternalError, { ErrorCode, GenericErrors } from \"./models/InternalComms/InternalError\";\nimport InternalStatus, { StatusCode } from \"./models/InternalComms/InternalStatus\";\nimport ServerClient from \"./ServerClient\";\n\nexport type DownloadErrors = GenericErrors | ErrorCode.TRANSFER_NOT_AVAILABLE;\n\nexport default new (class TransferClient {\n    public async Download(ticket: string): Promise<InternalStatus<string, DownloadErrors>> {\n        await ServerClient.wait4Init();\n\n        let response;\n        try {\n            response = await ServerClient.apiClient!.TransferController_Download(\n                {\n                    ticket: ticket\n                },\n                null,\n                {\n                    headers: {\n                        Accept: \"application/json, application/octet-stream\"\n                    }\n                }\n            );\n        } catch (stat) {\n            return new InternalStatus({\n                code: StatusCode.ERROR,\n                error: stat as InternalError<GenericErrors>\n            });\n        }\n\n        switch (response.status) {\n            case 200: {\n                return new InternalStatus({\n                    code: StatusCode.OK,\n                    payload: (response.data as unknown) as string\n                });\n            }\n            case 410: {\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(ErrorCode.TRANSFER_NOT_AVAILABLE, {\n                        errorMessage: response.data as Components.Schemas.ErrorMessageResponse\n                    })\n                });\n            }\n            default: {\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.UNHANDLED_RESPONSE,\n                        { axiosResponse: response },\n                        response\n                    )\n                });\n            }\n        }\n    }\n})();\n","import { TypedEmitter } from \"tiny-typed-emitter/lib\";\n\nimport { Components } from \"./generatedcode/_generated\";\nimport { DownloadedLog } from \"./models/DownloadedLog\";\nimport InternalError, { ErrorCode, GenericErrors } from \"./models/InternalComms/InternalError\";\nimport InternalStatus, { StatusCode } from \"./models/InternalComms/InternalStatus\";\nimport ServerClient from \"./ServerClient\";\nimport TransferClient, { DownloadErrors } from \"./TransferClient\";\n\ninterface IEvents {\n    loadAdminInfo: (\n        user: InternalStatus<Components.Schemas.AdministrationResponse, AdminInfoErrors>\n    ) => void;\n}\n\nexport type AdminInfoErrors =\n    | GenericErrors\n    | ErrorCode.ADMIN_GITHUB_RATE\n    | ErrorCode.ADMIN_GITHUB_ERROR;\n\nexport type RestartErrors = GenericErrors | ErrorCode.ADMIN_WATCHDOG_UNAVAIL;\n\nexport type UpdateErrors =\n    | GenericErrors\n    | ErrorCode.ADMIN_WATCHDOG_UNAVAIL\n    | ErrorCode.ADMIN_VERSION_NOT_FOUND\n    | ErrorCode.ADMIN_GITHUB_RATE\n    | ErrorCode.ADMIN_GITHUB_ERROR;\n\nexport type LogsErrors = GenericErrors | ErrorCode.ADMIN_LOGS_IO_ERROR;\n\nexport type LogErrors = GenericErrors | ErrorCode.ADMIN_LOGS_IO_ERROR;\n\nexport default new (class AdminClient extends TypedEmitter<IEvents> {\n    private _cachedAdminInfo?: InternalStatus<\n        Components.Schemas.AdministrationResponse,\n        ErrorCode.OK\n    >;\n    public get cachedAdminInfo() {\n        return this._cachedAdminInfo;\n    }\n    private loadingAdminInfo = false;\n\n    public constructor() {\n        super();\n        ServerClient.on(\"purgeCache\", () => {\n            this._cachedAdminInfo = undefined;\n        });\n    }\n\n    public async getAdminInfo(): Promise<\n        InternalStatus<Components.Schemas.AdministrationResponse, AdminInfoErrors>\n    > {\n        await ServerClient.wait4Init();\n        if (this._cachedAdminInfo) {\n            return this._cachedAdminInfo;\n        }\n\n        if (this.loadingAdminInfo) {\n            return await new Promise(resolve => {\n                const resolver = (\n                    user: InternalStatus<Components.Schemas.AdministrationResponse, AdminInfoErrors>\n                ) => {\n                    resolve(user);\n                    this.removeListener(\"loadAdminInfo\", resolver);\n                };\n                this.on(\"loadAdminInfo\", resolver);\n            });\n        }\n\n        this.loadingAdminInfo = true;\n\n        let response;\n        try {\n            response = await ServerClient.apiClient!.AdministrationController_Read();\n        } catch (stat) {\n            const res = new InternalStatus<\n                Components.Schemas.AdministrationResponse,\n                AdminInfoErrors\n            >({\n                code: StatusCode.ERROR,\n                error: stat as InternalError<AdminInfoErrors>\n            });\n            this.emit(\"loadAdminInfo\", res);\n            this.loadingAdminInfo = false;\n            return res;\n        }\n\n        switch (response.status) {\n            case 200: {\n                const thing = new InternalStatus<\n                    Components.Schemas.AdministrationResponse,\n                    ErrorCode.OK\n                >({\n                    code: StatusCode.OK,\n                    payload: response.data as Components.Schemas.AdministrationResponse\n                });\n\n                this._cachedAdminInfo = thing;\n                this.emit(\"loadAdminInfo\", thing);\n                this.loadingAdminInfo = false;\n                return thing;\n            }\n            case 424: {\n                const errorMessage = response.data as Components.Schemas.ErrorMessageResponse;\n                const thing = new InternalStatus<\n                    Components.Schemas.AdministrationResponse,\n                    ErrorCode.ADMIN_GITHUB_RATE\n                >({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.ADMIN_GITHUB_RATE,\n                        { errorMessage },\n                        response\n                    )\n                });\n                this.emit(\"loadAdminInfo\", thing);\n                this.loadingAdminInfo = false;\n                return thing;\n            }\n            case 429: {\n                const errorMessage = response.data as Components.Schemas.ErrorMessageResponse;\n                const thing = new InternalStatus<\n                    Components.Schemas.AdministrationResponse,\n                    ErrorCode.ADMIN_GITHUB_ERROR\n                >({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.ADMIN_GITHUB_ERROR,\n                        { errorMessage },\n                        response\n                    )\n                });\n                this.emit(\"loadAdminInfo\", thing);\n                this.loadingAdminInfo = false;\n                return thing;\n            }\n            default: {\n                const res = new InternalStatus<\n                    Components.Schemas.AdministrationResponse,\n                    ErrorCode.UNHANDLED_RESPONSE\n                >({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.UNHANDLED_RESPONSE,\n                        { axiosResponse: response },\n                        response\n                    )\n                });\n                this.emit(\"loadAdminInfo\", res);\n                this.loadingAdminInfo = false;\n                return res;\n            }\n        }\n    }\n\n    public async restartServer(): Promise<InternalStatus<null, RestartErrors>> {\n        await ServerClient.wait4Init();\n\n        let response;\n        try {\n            response = await ServerClient.apiClient!.AdministrationController_Delete();\n        } catch (stat) {\n            return new InternalStatus({\n                code: StatusCode.ERROR,\n                error: stat as InternalError<RestartErrors>\n            });\n        }\n\n        switch (response.status) {\n            case 204: {\n                return new InternalStatus({ code: StatusCode.OK, payload: null });\n            }\n            case 422: {\n                const errorMessage = response.data as Components.Schemas.ErrorMessageResponse;\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.ADMIN_WATCHDOG_UNAVAIL,\n                        { errorMessage },\n                        response\n                    )\n                });\n            }\n            default: {\n                return new InternalStatus<null, ErrorCode.UNHANDLED_RESPONSE>({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.UNHANDLED_RESPONSE,\n                        { axiosResponse: response },\n                        response\n                    )\n                });\n            }\n        }\n    }\n\n    public async updateServer(newVersion: string): Promise<InternalStatus<null, UpdateErrors>> {\n        await ServerClient.wait4Init();\n\n        let response;\n        try {\n            response = await ServerClient.apiClient!.AdministrationController_Update(null, {\n                newVersion\n            });\n        } catch (stat) {\n            return new InternalStatus({\n                code: StatusCode.ERROR,\n                error: stat as InternalError<UpdateErrors>\n            });\n        }\n\n        switch (response.status) {\n            case 202: {\n                return new InternalStatus({ code: StatusCode.OK, payload: null });\n            }\n            case 410: {\n                const errorMessage = response.data as Components.Schemas.ErrorMessageResponse;\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.ADMIN_VERSION_NOT_FOUND,\n                        { errorMessage },\n                        response\n                    )\n                });\n            }\n            case 422: {\n                const errorMessage = response.data as Components.Schemas.ErrorMessageResponse;\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.ADMIN_WATCHDOG_UNAVAIL,\n                        { errorMessage },\n                        response\n                    )\n                });\n            }\n            case 424: {\n                const errorMessage = response.data as Components.Schemas.ErrorMessageResponse;\n                return new InternalStatus<null, ErrorCode.ADMIN_GITHUB_RATE>({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.ADMIN_GITHUB_RATE,\n                        { errorMessage },\n                        response\n                    )\n                });\n            }\n            case 429: {\n                const errorMessage = response.data as Components.Schemas.ErrorMessageResponse;\n                return new InternalStatus<null, ErrorCode.ADMIN_GITHUB_ERROR>({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.ADMIN_GITHUB_ERROR,\n                        { errorMessage },\n                        response\n                    )\n                });\n            }\n            default: {\n                return new InternalStatus<null, ErrorCode.UNHANDLED_RESPONSE>({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.UNHANDLED_RESPONSE,\n                        { axiosResponse: response },\n                        response\n                    )\n                });\n            }\n        }\n    }\n\n    public async getLogs(): Promise<\n        InternalStatus<Components.Schemas.LogFileResponse[], LogsErrors>\n    > {\n        await ServerClient.wait4Init();\n\n        let response;\n        try {\n            response = await ServerClient.apiClient!.AdministrationController_ListLogs({\n                pageSize: 100,\n                page: 1\n            });\n        } catch (stat) {\n            return new InternalStatus({\n                code: StatusCode.ERROR,\n                error: stat as InternalError<LogsErrors>\n            });\n        }\n\n        switch (response.status) {\n            case 200: {\n                return new InternalStatus({\n                    code: StatusCode.OK,\n                    payload: (response.data as Components.Schemas.PaginatedLogFileResponse)!.content\n                });\n            }\n            case 409: {\n                const errorMessage = response.data as Components.Schemas.ErrorMessageResponse;\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.ADMIN_LOGS_IO_ERROR,\n                        { errorMessage },\n                        response\n                    )\n                });\n            }\n            default: {\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.UNHANDLED_RESPONSE,\n                        { axiosResponse: response },\n                        response\n                    )\n                });\n            }\n        }\n    }\n\n    public async getLog(\n        logName: string\n    ): Promise<InternalStatus<DownloadedLog, LogErrors | DownloadErrors>> {\n        await ServerClient.wait4Init();\n\n        let response;\n        try {\n            response = await ServerClient.apiClient!.AdministrationController_GetLog({\n                path: logName\n            });\n        } catch (stat) {\n            return new InternalStatus({\n                code: StatusCode.ERROR,\n                error: stat as InternalError<GenericErrors>\n            });\n        }\n        switch (response.status) {\n            case 200: {\n                const contents = await TransferClient.Download(\n                    (response.data as Components.Schemas.LogFileResponse).fileTicket\n                );\n                if (contents.code === StatusCode.OK) {\n                    //Object.assign() is a funky function but all it does is copy everything from the second object to the first object\n                    const temp: DownloadedLog = Object.assign(\n                        { content: contents.payload },\n                        response.data as Components.Schemas.LogFileResponse\n                    );\n                    return new InternalStatus({\n                        code: StatusCode.OK,\n                        payload: temp\n                    });\n                } else {\n                    return new InternalStatus({\n                        code: StatusCode.ERROR,\n                        error: contents.error\n                    });\n                }\n            }\n            case 409: {\n                const errorMessage = response.data as Components.Schemas.ErrorMessageResponse;\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.ADMIN_LOGS_IO_ERROR,\n                        { errorMessage },\n                        response\n                    )\n                });\n            }\n            default: {\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.UNHANDLED_RESPONSE,\n                        { axiosResponse: response },\n                        response\n                    )\n                });\n            }\n        }\n    }\n})();\n"],"sourceRoot":""}